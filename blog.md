Week 1
I started by skimming over the specs. From my understanding, I need to model Device, which sits on a planet stationarily and can transfer/receive files from a Satellite, which orbits around the planet, by simulated using a BlackoutController. Then I look deeper into each of this class to see what fields/method they need. A satellite can either be of type Standard, Teleport, or Relay. Since TeleportingSatellite and RelaySatellite contains everything a StandardSatellite have, I let TeleportingSatellite and RelaySatellite inherit from StandardSatelltie, however they are unique in their abilities of teleporting and relaying, so they have their own methods for doing so. Whereas for Device, there're HandheldDevice, LaptopDevice, DesktopDevice which are basically the same thing just with different value for the maxRange field, so I didn't bother making subclasses for them, and instead have a Device class to cover all. To help with file transferring from device to satellites or vice versa, I made a FileTransfer class with methods to allow this, which Satelite and Device can just use.

Week 2/Week 3
My design has changed dramatically over these 2 weeks.
Seeing how many features Devices share with Satellites, they have Angle positions, they have height, they have file transferring, they even have the ability to move in Task 3; I decided to make a parent class for them, called Entity. This makes my programming so much more efficient. Instead of having to check whether an Entity is a satellite or device from now on, I simply call that method in the Entity class. If the entity has some special behavior, polymorphism will cover it, which reduces complexity, and increases abstraction and usability of my system.
After learning the design principle of dividing up the code to their relevant classes instead of having everything in same place, I've made a few changes. Instead of setting up the Entity's velocity, maxRange, downloadSpeed, etc in the Entity class using switch and cases, I moved that code to their respective classes. Each class (Satellites/Devices) would call super to set up, but then would use mutator methods set up their fields with their own values. This makes it easier to maintain and add new Entity types in the future, simply by making a class for it and construct it when needed.
For devices, I've decided to make subclasses for Handheld, Laptop, and Desktop for the same reason. Having a class that calls just super() underutilizes its potential. Have subclasses like this also made it easier to check its class using 'instance of' instead of having to call getType() and equals().
I made a FileTransfer class to manage transferring of files. The FileInfoResponse class wasn't good enough, since I'm not allowed to modify it directly. Every tick, the BlackoutController handles File Transferring by going through a list of FileTransfer objects created during the start of file transfer.
The implementation of this class however causes many accidents that violate the Law of Demeter. Since the FileTransfer connects to Entities, which connects FileInfoResponses; BlackoutController often have to go through Entities' neighbors in order to properly store and keep track of the files. This is however necessary, as without it, keeping track of what file is being transferred, how many bytes were downloaded, etc. will be so much more complicated, which as a programmer/designer I didn't think was worth it.

Overall this assignment was really fun. Designing the UML alongside coding made OOP concepts easier to be understood, as having someting visual and practically implementing it improves clarity and understandability of the system and its requirements. It was challenging in the sense that I have to find the relationships between these classes that make the most sense and what classes and methods would make future features be implemented easier, aka refactoring, but when refactoring is done, the rest becomes so much clearer and intuitive to implement.
